{"version":3,"file":"web/openhps-imu.es.js","mappings":";;;;;;;;;;;;;AAAA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AAC0J;AAC1J,8CAA8C,oDAAS;AACvD;AACA;AACA,IAAI,iEAAkB;AACtB;AACA;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,oDAAS;AACvC;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,sDAAW;AACzC;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,sDAAW;AACzC;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,yDAAc;AAC5C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,0DAAe;AAC7C;AACA;AACA,IAAI,iEAAkB;AACtB;AACwB;AACxB;;;;;;;;;;;;;;ACpDA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AAC4G;AAC5G,oDAAoD,qDAAU;AAC9D;AACA;AACA,IAAI,iEAAkB;AACtB;AACA;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,oDAAS;AACvC;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB,8BAA8B,uDAAY;AAC1C;AACA;AACA,IAAI,iEAAkB;AACtB;AAC2B;AAC3B;;;;;;;;;;;;;;;;ACpC+B;AACG;AAClC;;;;;;;;;;;;;;;;;;;;;;;;;ACF6B;AACJ;AACzB;;;;;;;;;;;;;;ACFkE;AAC3D,gDAAgD,+DAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAqB;AAC7D;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACjCqE;AAC9D,yCAAyC,+DAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACjCsF;AAC/E,oCAAoC,+DAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAY,UAAU,+EAAoC;AACtF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;;;;;;;;;;;;;;;ACnEA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACwL;AACjL,sCAAsC,yDAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yDAAc,2CAA2C,8EAAmC;AAC1I;AACA;AACA,6CAA6C,4DAAiB;AAC9D;AACA;AACA;AACA,2DAA2D,2DAAgB;AAC3E;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAA2C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAuB,CAAC,uDAAY;AACxC;AACA;AACA;AACA,IAAI,sEAAuB,CAAC,uDAAY;AACxC;AACA;AACA;AACA,IAAI,iEAAkB;AACtB;AACA;AACA;AACA,IAAI,iEAAkB;AACtB;AACA;AACA;AACA,IAAI,iEAAkB;AACtB;AACyB;AACzB;;;;;;;;;;;;;;ACtLkE;AAC3D,gDAAgD,+DAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAqB;AAC7D;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;AC9B6H;AACtH,sCAAsC,+DAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAgB;AAC/C,oDAAoD,2DAAgB;AACpE,uCAAuC,8DAAmB,4DAA4D,0DAAe;AACrI;AACA,8CAA8C,yDAAc,2CAA2C,8EAAmC;AAC1I;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;AClCoK;AAC7J,qCAAqC,+DAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,8DAAmB,4DAA4D,0DAAe;AAC5H;AACA;AACA;AACA,8DAA8D,yDAAc;AAC5E,gEAAgE,0DAAe;AAC/E;AACA;AACA,qCAAqC,4DAAiB;AACtD,+BAA+B,4DAAiB;AAChD,kDAAkD,kDAAO;AACzD;AACA,oCAAoC,4DAAiB;AACrD;AACA;AACA;AACA;AACA,kDAAkD,kDAAO;AACzD,kDAAkD,oDAAS;AAC3D,kDAAkD,kDAAO;AACzD,8CAA8C,wEAA6B,KAAK,kDAAO;AACvF;AACA;AACA;AACA,8CAA8C,sDAAW;AACzD;AACA;AACA,yDAAyD,2DAAgB,kEAAkE,2DAAgB;AAC3J;AACA,sCAAsC,gEAAqB;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACxDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AAC9C,0CAA0C,+DAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACjE8C;AAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACD8B;AACe;AACO;AACZ;AACY;AACV;AACA;AACD;AACzC;;;;;;;;;;;;;;;ACRuF;AAC7C;AACnC,+BAA+B,qDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAY;AAC9C,yCAAyC,uDAAY;AACrD,4CAA4C,0DAAe;AAC3D,+CAA+C,uDAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,gEAAqB;AACpE,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACnCmC;AACnC;;;;;;;;;;ACDA,eAAe,YAAY,6BAA6B;AACxD;AACA,qBAAqB,4lEAA4lE;;;;;;SCFjnE;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAwB;AACD;AACvB,iC","sources":["webpack://@openhps/imu/./dist/esm/data/IMUDataFrame.js","webpack://@openhps/imu/./dist/esm/data/IMUSensorObject.js","webpack://@openhps/imu/./dist/esm/data/index.js","webpack://@openhps/imu/./dist/esm/nodes/index.js","webpack://@openhps/imu/./dist/esm/nodes/processing/AbsoluteOrientationProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/AccelerationProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/GravityProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/PedometerProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/RelativeOrientationProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/VelocityCalculationNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/VelocityProcessingNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/calibration/MagnetometerCalibrationNode.js","webpack://@openhps/imu/./dist/esm/nodes/processing/calibration/index.js","webpack://@openhps/imu/./dist/esm/nodes/processing/index.js","webpack://@openhps/imu/./dist/esm/nodes/source/IMUBrowserSource.js","webpack://@openhps/imu/./dist/esm/nodes/source/index.js","webpack://@openhps/imu/external module \"./openhps-core.es.js\"","webpack://@openhps/imu/webpack/bootstrap","webpack://@openhps/imu/webpack/runtime/define property getters","webpack://@openhps/imu/webpack/runtime/hasOwnProperty shorthand","webpack://@openhps/imu/./dist/esm/index.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nimport { SerializableObject, SerializableMember, DataFrame, Magnetism, Acceleration, LinearVelocity, AngularVelocity, Orientation, } from '@openhps/core';\r\nlet IMUDataFrame = class IMUDataFrame extends DataFrame {\r\n};\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Number)\r\n], IMUDataFrame.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Magnetism)\r\n], IMUDataFrame.prototype, \"magnetism\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUDataFrame.prototype, \"acceleration\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUDataFrame.prototype, \"linearAcceleration\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUDataFrame.prototype, \"gravity\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Orientation)\r\n], IMUDataFrame.prototype, \"relativeOrientation\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Orientation)\r\n], IMUDataFrame.prototype, \"absoluteOrientation\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", LinearVelocity)\r\n], IMUDataFrame.prototype, \"linearVelocity\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", AngularVelocity)\r\n], IMUDataFrame.prototype, \"angularVelocity\", void 0);\r\nIMUDataFrame = __decorate([\r\n    SerializableObject()\r\n], IMUDataFrame);\r\nexport { IMUDataFrame };\r\n//# sourceMappingURL=IMUDataFrame.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nimport { SerializableObject, SerializableMember, DataObject, Magnetism, Acceleration } from '@openhps/core';\r\nlet IMUSensorObject = class IMUSensorObject extends DataObject {\r\n};\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Number)\r\n], IMUSensorObject.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Magnetism)\r\n], IMUSensorObject.prototype, \"magnetism\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUSensorObject.prototype, \"acceleration\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUSensorObject.prototype, \"linearAcceleration\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Acceleration)\r\n], IMUSensorObject.prototype, \"gravity\", void 0);\r\nIMUSensorObject = __decorate([\r\n    SerializableObject()\r\n], IMUSensorObject);\r\nexport { IMUSensorObject };\r\n//# sourceMappingURL=IMUSensorObject.js.map","export * from './IMUDataFrame';\r\nexport * from './IMUSensorObject';\r\n//# sourceMappingURL=index.js.map","export * from './processing';\r\nexport * from './source';\r\n//# sourceMappingURL=index.js.map","import { FilterProcessingNode, Orientation } from '@openhps/core';\r\nexport class AbsoluteOrientationProcessingNode extends FilterProcessingNode {\r\n    initFilter(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (frame.angularVelocity || frame.acceleration === undefined) {\r\n                reject(new Error(`Relative rotation processing requires accelerometer and gyroscope readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.acceleration;\r\n            const mag = frame.magnetism;\r\n            const pitch = Math.atan2(-accl.x, Math.sqrt(accl.z * accl.z + accl.y * accl.y));\r\n            const roll = Math.atan2(accl.y, Math.sqrt(accl.z * accl.z + accl.x * accl.x));\r\n            const Xh = mag.x * Math.cos(pitch) +\r\n                mag.y * Math.sin(roll) * Math.sin(pitch) +\r\n                mag.z * Math.cos(roll) * Math.sin(pitch);\r\n            const Yh = mag.y * Math.cos(roll) - mag.z * Math.sin(roll);\r\n            let azimuth = Math.atan2(Yh, Xh);\r\n            if (azimuth < 0) {\r\n                azimuth = 2 * Math.PI + azimuth;\r\n            }\r\n            frame.absoluteOrientation = Orientation.fromEuler([pitch, roll, azimuth]);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=AbsoluteOrientationProcessingNode.js.map","import { FilterProcessingNode, LinearVelocity } from '@openhps/core';\r\nexport class AccelerationProcessingNode extends FilterProcessingNode {\r\n    initFilter(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.acceleration && !frame.linearAcceleration) {\r\n                return reject(new Error(`Acceleration processing requires accelerometer readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.linearAcceleration || frame.acceleration;\r\n            const dt = 1000 / frame.frequency;\r\n            frame.linearVelocity = LinearVelocity.fromArray(accl.clone().multiplyScalar(dt).toArray());\r\n            const position = object.getPosition();\r\n            if (!position) {\r\n                return resolve(object);\r\n            }\r\n            if (!position.linearVelocity) {\r\n                position.linearVelocity = frame.linearVelocity.clone();\r\n            }\r\n            else {\r\n                position.linearVelocity.add(frame.linearVelocity);\r\n            }\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=AccelerationProcessingNode.js.map","import { FilterProcessingNode, Acceleration, AccelerationUnit, } from '@openhps/core';\r\nexport class GravityProcessingNode extends FilterProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.options.method = this.options.method || GravityProcessingMethod.LOW_PASS;\r\n    }\r\n    initFilter(object, frame, options) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.acceleration) {\r\n                return reject(new Error(`Gravity processing requires accelerometer readings!`));\r\n            }\r\n            resolve(options);\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            let method;\r\n            if (frame.linearAcceleration) {\r\n                method = GravityProcessingMethod.LINEAR_ACCELERATION;\r\n            }\r\n            else if (frame.relativeOrientation) {\r\n                method = GravityProcessingMethod.RELATIVE_ORIENTATION;\r\n            }\r\n            else if (frame.absoluteOrientation) {\r\n                method = GravityProcessingMethod.ABSOLUTE_ORIENTATION;\r\n            }\r\n            switch (method) {\r\n                case GravityProcessingMethod.LINEAR_ACCELERATION:\r\n                    this._fromLinearAcceleration(frame);\r\n                    break;\r\n                case GravityProcessingMethod.LOW_PASS:\r\n                    this._usingLPFilter(frame);\r\n                    break;\r\n                case GravityProcessingMethod.ABSOLUTE_ORIENTATION:\r\n                    this._fromAbsoluteOrientation(frame);\r\n                    break;\r\n                default:\r\n                case GravityProcessingMethod.RELATIVE_ORIENTATION:\r\n                    this._fromRelativeOrientation(frame);\r\n                    break;\r\n            }\r\n            resolve(object);\r\n        });\r\n    }\r\n    _fromLinearAcceleration(frame) {\r\n        frame.gravity = frame.acceleration.clone().sub(frame.linearAcceleration);\r\n    }\r\n    _usingLPFilter(frame) {\r\n        frame.gravity = new Acceleration();\r\n        frame.linearAcceleration = frame.acceleration.clone().sub(frame.gravity);\r\n    }\r\n    _fromRelativeOrientation(frame) {\r\n        frame.linearAcceleration = frame.acceleration.clone().multiply(frame.relativeOrientation.toEuler().toVector3());\r\n        frame.gravity = frame.acceleration.clone().sub(frame.linearAcceleration);\r\n    }\r\n    _fromAbsoluteOrientation(frame) {\r\n        frame.gravity = new Acceleration(0, 0, 1, AccelerationUnit.GRAVITATIONAL_FORCE).applyQuaternion(frame.absoluteOrientation);\r\n        frame.linearAcceleration = frame.acceleration.clone().sub(frame.gravity);\r\n    }\r\n}\r\nexport var GravityProcessingMethod;\r\n(function (GravityProcessingMethod) {\r\n    GravityProcessingMethod[GravityProcessingMethod[\"LOW_PASS\"] = 0] = \"LOW_PASS\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"ABSOLUTE_ORIENTATION\"] = 1] = \"ABSOLUTE_ORIENTATION\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"RELATIVE_ORIENTATION\"] = 2] = \"RELATIVE_ORIENTATION\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"LINEAR_ACCELERATION\"] = 3] = \"LINEAR_ACCELERATION\";\r\n})(GravityProcessingMethod || (GravityProcessingMethod = {}));\r\n//# sourceMappingURL=GravityProcessingNode.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nimport { Acceleration, LinearVelocity, SerializableArrayMember, SerializableMember, SerializableObject, LinearVelocityUnit, Vector3, LengthUnit, ProcessingNode, } from '@openhps/core';\r\nexport class PedometerProcessingNode extends ProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.options.windowSize = this.options.windowSize || 1;\r\n        this.options.minPeak = this.options.minPeak || 2;\r\n        this.options.maxPeak = this.options.maxPeak || 8;\r\n        this.options.minStepTime = this.options.minStepTime || 0.3;\r\n        this.options.peakThreshold = this.options.peakThreshold || 0.5;\r\n        this.options.maxStepTime = this.options.maxStepTime || 0.8;\r\n        this.options.meanFilterSize = this.options.meanFilterSize || 1;\r\n        this.options.minConsecutiveSteps = this.options.minConsecutiveSteps || 3;\r\n        this.options.stepSize = this.options.stepSize || 0.7;\r\n    }\r\n    process(frame) {\r\n        return new Promise((resolve, reject) => {\r\n            let pedometerData;\r\n            this.getNodeData(frame.source)\r\n                .then((data) => {\r\n                if (!data) {\r\n                    data = new PedometerData();\r\n                }\r\n                data.add(frame);\r\n                const windowSize = Math.floor(this.options.windowSize * data.frequency);\r\n                if (data.accelerometerData.length > 4 * windowSize) {\r\n                    data.shift();\r\n                }\r\n                pedometerData = data;\r\n                return this.processPedometer(pedometerData);\r\n            })\r\n                .then((steps) => {\r\n                const previousStep = steps.indexOf(pedometerData.lastStepIndex);\r\n                if (previousStep !== -1) {\r\n                    steps = steps.slice(previousStep + 1);\r\n                }\r\n                if (steps.length > 0) {\r\n                    pedometerData.lastStepIndex = steps[steps.length - 1];\r\n                }\r\n                const stepCount = steps.length;\r\n                const distance = this.options.stepSize * stepCount;\r\n                const position = frame.source.getPosition();\r\n                position.timestamp = frame.createdTimestamp;\r\n                position.linearVelocity = new LinearVelocity(distance / this.options.windowSize, 0, 0, LinearVelocityUnit.METER_PER_SECOND);\r\n                const orientation = frame.absoluteOrientation || position.orientation;\r\n                if (orientation) {\r\n                    const relativePosition = Vector3.fromArray([distance / this.options.windowSize, 0, 0]);\r\n                    const eulerOrientation = orientation.toEuler();\r\n                    eulerOrientation.x = 0;\r\n                    eulerOrientation.y = 0;\r\n                    position.fromVector(position.toVector3(LengthUnit.METER).add(relativePosition.applyEuler(eulerOrientation)));\r\n                }\r\n                return this.setNodeData(frame.source, pedometerData);\r\n            })\r\n                .then(() => {\r\n                resolve(frame);\r\n            })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    processPedometer(data) {\r\n        return new Promise((resolve) => {\r\n            const windowSize = Math.floor(this.options.windowSize * data.frequency);\r\n            const taoMin = this.options.minStepTime * data.frequency;\r\n            const taoMax = this.options.maxStepTime * data.frequency;\r\n            const verticalComponent = this._extractVerticalComponents(data.accelerometerData, data.attitudeData);\r\n            if (verticalComponent.length < windowSize) {\r\n                return resolve([]);\r\n            }\r\n            let smoothedVerticalComponent = verticalComponent;\r\n            if (this.options.meanFilterSize > 1) {\r\n                smoothedVerticalComponent = this._meanFilter(verticalComponent, this.options.meanFilterSize);\r\n            }\r\n            const window = verticalComponent.slice(0, windowSize);\r\n            let windowMax = Math.max(this.options.minPeak, Math.min(this.options.maxPeak, Math.max(...window)));\r\n            let windowSum = window.reduce((a, b) => a + b);\r\n            const windowAvg = windowSum / windowSize;\r\n            const offset = Math.ceil(windowSize / 2);\r\n            let steps = [];\r\n            let lastPeak = data.lastStepIndex;\r\n            for (let i = offset; i < verticalComponent.length - offset - 1; i++) {\r\n                if (verticalComponent[i] >\r\n                    Math.max(this.options.minPeak, this.options.peakThreshold * windowMax + windowAvg) &&\r\n                    smoothedVerticalComponent[i] >= smoothedVerticalComponent[i - 1] &&\r\n                    smoothedVerticalComponent[i] > smoothedVerticalComponent[i + 1] &&\r\n                    lastPeak < i - taoMin) {\r\n                    if (verticalComponent[i] < this.options.maxPeak)\r\n                        steps.push(i);\r\n                    lastPeak = i;\r\n                }\r\n                window.push(verticalComponent[i + offset]);\r\n                const removed = window.shift();\r\n                windowSum += verticalComponent[i + offset] - removed;\r\n                if (removed >= windowMax || verticalComponent[i + offset] > windowMax) {\r\n                    windowMax = Math.max(this.options.minPeak, Math.min(this.options.maxPeak, Math.max(...window)));\r\n                }\r\n            }\r\n            if (this.options.minConsecutiveSteps > 1) {\r\n                let consecutivePeaks = 1;\r\n                let i = steps.length;\r\n                while (i--) {\r\n                    if (i === 0 || steps[i] - steps[i - 1] < taoMax) {\r\n                        consecutivePeaks++;\r\n                    }\r\n                    else {\r\n                        if (consecutivePeaks < this.options.minConsecutiveSteps) {\r\n                            steps.splice(i, consecutivePeaks);\r\n                        }\r\n                        consecutivePeaks = 1;\r\n                    }\r\n                }\r\n                if (steps.length < this.options.minConsecutiveSteps) {\r\n                    steps = [];\r\n                }\r\n            }\r\n            resolve(steps);\r\n        });\r\n    }\r\n    _extractVerticalComponents(accelerometerData, attitudeData) {\r\n        return accelerometerData.map((acceleration, i) => {\r\n            const attitude = attitudeData[i].clone();\r\n            attitude.z = 0;\r\n            return acceleration.clone().applyEuler(attitude).getComponent(2);\r\n        });\r\n    }\r\n    _meanFilter(arr, size) {\r\n        const window = [];\r\n        return arr.map((val) => {\r\n            if (window.length >= size)\r\n                window.shift();\r\n            window.push(val);\r\n            return window.reduce((a, b) => a + b) / arr.length;\r\n        });\r\n    }\r\n}\r\nlet PedometerData = class PedometerData {\r\n    constructor() {\r\n        this.accelerometerData = [];\r\n        this.attitudeData = [];\r\n        this.lastStepIndex = -Infinity;\r\n    }\r\n    add(frame) {\r\n        this.accelerometerData.push(frame.linearAcceleration);\r\n        this.attitudeData.push(frame.absoluteOrientation.toEuler('ZYX'));\r\n        this.frequency = frame.frequency;\r\n        return this;\r\n    }\r\n    shift() {\r\n        this.lastStepIndex--;\r\n        this.accelerometerData.shift();\r\n        this.attitudeData.shift();\r\n        return this;\r\n    }\r\n};\r\n__decorate([\r\n    SerializableArrayMember(Acceleration),\r\n    __metadata(\"design:type\", Array)\r\n], PedometerData.prototype, \"accelerometerData\", void 0);\r\n__decorate([\r\n    SerializableArrayMember(Acceleration),\r\n    __metadata(\"design:type\", Array)\r\n], PedometerData.prototype, \"attitudeData\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Number)\r\n], PedometerData.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    SerializableMember(),\r\n    __metadata(\"design:type\", Object)\r\n], PedometerData.prototype, \"lastStepIndex\", void 0);\r\nPedometerData = __decorate([\r\n    SerializableObject()\r\n], PedometerData);\r\nexport { PedometerData };\r\n//# sourceMappingURL=PedometerProcessingNode.js.map","import { FilterProcessingNode, Orientation } from '@openhps/core';\r\nexport class RelativeOrientationProcessingNode extends FilterProcessingNode {\r\n    initFilter(_, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.angularVelocity || !frame.acceleration) {\r\n                return reject(new Error(`Relative rotation processing requires accelerometer and gyroscope readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame, filter) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.acceleration;\r\n            const gyro = object.getPosition().angularVelocity || frame.angularVelocity;\r\n            const bias = 0.98;\r\n            const dt = 1000 / frame.frequency;\r\n            const norm = Math.sqrt(Math.pow(accl.x, 2) + Math.pow(accl.y, 2) + Math.pow(accl.z, 2));\r\n            const scale = Math.PI / 2;\r\n            const alpha = filter.alpha + gyro.z * dt;\r\n            const beta = bias * (filter.beta + gyro.x * dt) + (1.0 - bias) * ((accl.x * scale) / norm);\r\n            const gamma = bias * (filter.gamma + gyro.y * dt) + (1.0 - bias) * ((accl.y * -scale) / norm);\r\n            frame.relativeOrientation = Orientation.fromEuler([beta, gamma, alpha]);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=RelativeOrientationProcessingNode.js.map","import { TimeService, TimeUnit, LengthUnit, LinearVelocityUnit, ObjectProcessingNode, LinearVelocity, } from '@openhps/core';\r\nexport class VelocityCalculationNode extends ObjectProcessingNode {\r\n    processObject(object) {\r\n        return new Promise((resolve, reject) => {\r\n            if (object.getPosition()) {\r\n                this.predictVelocity(object).then(resolve).catch(reject);\r\n            }\r\n            else {\r\n                resolve(object);\r\n            }\r\n        });\r\n    }\r\n    predictVelocity(object) {\r\n        return new Promise((resolve) => {\r\n            const service = this.model.findDataService(object);\r\n            const position = object.getPosition();\r\n            service\r\n                .findByUID(object.uid)\r\n                .then((existingObject) => {\r\n                const existingPosition = existingObject.getPosition();\r\n                const difference = position\r\n                    .toVector3(LengthUnit.METER)\r\n                    .sub(existingPosition.toVector3(LengthUnit.METER));\r\n                const timeDifference = TimeService.getUnit().convert(position.timestamp - existingPosition.timestamp, TimeUnit.SECOND);\r\n                difference.divideScalar(timeDifference);\r\n                position.linearVelocity = new LinearVelocity(difference.x, difference.y, difference.z, LinearVelocityUnit.METER_PER_SECOND);\r\n                resolve(object);\r\n            })\r\n                .catch(() => {\r\n                resolve(object);\r\n            });\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=VelocityCalculationNode.js.map","import { TimeService, TimeUnit, LengthUnit, AngularVelocity, ObjectProcessingNode, LinearVelocity, Matrix4, Vector3, AxisAngle, Orientation, } from '@openhps/core';\r\nexport class VelocityProcessingNode extends ObjectProcessingNode {\r\n    processObject(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (object.getPosition()) {\r\n                const lastPosition = object.getPosition();\r\n                if (lastPosition.linearVelocity || lastPosition.angularVelocity) {\r\n                    this.applyVelocity(object, frame).then(resolve).catch(reject);\r\n                }\r\n                else {\r\n                    resolve(object);\r\n                }\r\n            }\r\n            else {\r\n                resolve(object);\r\n            }\r\n        });\r\n    }\r\n    applyVelocity(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const lastPosition = object.getPosition();\r\n            const deltaTime = TimeService.getUnit().convert(frame.createdTimestamp - lastPosition.timestamp, TimeUnit.SECOND);\r\n            if (deltaTime < 0) {\r\n                return resolve(object);\r\n            }\r\n            const linear = lastPosition.linearVelocity || new LinearVelocity();\r\n            const angular = lastPosition.angularVelocity || new AngularVelocity();\r\n            const linearMovement = linear.clone().multiplyScalar(deltaTime);\r\n            const angularMovement = angular.clone().multiplyScalar(deltaTime);\r\n            const relativePosition = Vector3.fromArray([0, 0, 0]);\r\n            if (angular.equals(Vector3.fromArray([0, 0, 0]))) {\r\n                relativePosition.applyMatrix4(new Matrix4().makeTranslation(linearMovement.x, linearMovement.y, linearMovement.z));\r\n            }\r\n            else if (!linear.equals(Vector3.fromArray([0, 0, 0]))) {\r\n                const rX = linear.clone().divideScalar(angular.x === 0 ? 1 : angular.x);\r\n                const rY = linear.clone().divideScalar(angular.y === 0 ? 1 : angular.y);\r\n                const rZ = linear.clone().divideScalar(angular.z === 0 ? 1 : angular.z);\r\n                const rMin = rX.min(rY).min(rZ);\r\n                relativePosition.applyMatrix4(new Matrix4().makeTranslation(-rMin.x, -rMin.y, -rMin.z));\r\n                relativePosition.applyMatrix4(new AxisAngle(angularMovement.x, angularMovement.y, angularMovement.z).toRotationMatrix());\r\n                relativePosition.applyMatrix4(new Matrix4().makeTranslation(rMin.x, rMin.y, rMin.z));\r\n                relativePosition.applyMatrix4(Matrix4.rotationFromAxisAngle(new Vector3(angular.x !== 0 ? 1 : 0, angular.y !== 0 ? 1 : 0, angular.z !== 0 ? 1 : 0), Math.PI / 2));\r\n            }\r\n            const newPosition = lastPosition.clone();\r\n            if (!newPosition.orientation) {\r\n                newPosition.orientation = new Orientation();\r\n            }\r\n            newPosition.timestamp = frame.createdTimestamp;\r\n            newPosition.fromVector(newPosition.toVector3(LengthUnit.METER).add(relativePosition.applyQuaternion(newPosition.orientation)), LengthUnit.METER);\r\n            const newOrientation = newPosition.orientation.toEuler().toVector3().add(angular.multiplyScalar(deltaTime));\r\n            newPosition.orientation = Orientation.fromEuler(newOrientation);\r\n            object.setPosition(newPosition);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=VelocityProcessingNode.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { ObjectProcessingNode } from '@openhps/core';\r\nexport class MagnetometerCalibrationNode extends ObjectProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n    processObject(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            this.getNodeData(object)\r\n                .then((calibrationData) => __awaiter(this, void 0, void 0, function* () {\r\n                if (calibrationData === undefined) {\r\n                    calibrationData = {\r\n                        xMax: 0,\r\n                        xMin: 0,\r\n                        yMax: 0,\r\n                        yMin: 0,\r\n                        zMax: 0,\r\n                        zMin: 0,\r\n                        count: 0,\r\n                        scaleX: NaN,\r\n                        scaleY: NaN,\r\n                        scaleZ: NaN,\r\n                    };\r\n                }\r\n                if (isNaN(calibrationData.scaleX) &&\r\n                    calibrationData.count < this.options.count &&\r\n                    this.options.count !== -1) {\r\n                    calibrationData.xMax = Math.max(frame.magnetism.x, calibrationData.xMax);\r\n                    calibrationData.xMin = Math.min(frame.magnetism.x, calibrationData.xMin);\r\n                    calibrationData.yMax = Math.max(frame.magnetism.y, calibrationData.yMax);\r\n                    calibrationData.yMin = Math.min(frame.magnetism.y, calibrationData.yMin);\r\n                    calibrationData.zMax = Math.max(frame.magnetism.z, calibrationData.zMax);\r\n                    calibrationData.zMin = Math.min(frame.magnetism.z, calibrationData.zMin);\r\n                    calibrationData.count += 1;\r\n                    yield this.setNodeData(object, calibrationData);\r\n                }\r\n                else if (isNaN(calibrationData.scaleX) && calibrationData.count >= this.options.count) {\r\n                    const avgDeltaX = (calibrationData.xMax + calibrationData.xMin) / 2;\r\n                    const avgDeltaY = (calibrationData.yMax + calibrationData.yMin) / 2;\r\n                    const avgDeltaZ = (calibrationData.zMax + calibrationData.zMin) / 2;\r\n                    const avgDelta = (avgDeltaX + avgDeltaY + avgDeltaZ) / 3;\r\n                    calibrationData.scaleX = avgDelta / avgDeltaX;\r\n                    calibrationData.scaleY = avgDelta / avgDeltaY;\r\n                    calibrationData.scaleZ = avgDelta / avgDeltaZ;\r\n                    yield this.setNodeData(object, calibrationData);\r\n                }\r\n                else {\r\n                    frame.magnetism.x = frame.magnetism.x * calibrationData.scaleX;\r\n                    frame.magnetism.y = frame.magnetism.y * calibrationData.scaleY;\r\n                    frame.magnetism.z = frame.magnetism.z * calibrationData.scaleZ;\r\n                }\r\n                resolve(object);\r\n            }))\r\n                .catch(reject);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=MagnetometerCalibrationNode.js.map","export * from './MagnetometerCalibrationNode';\r\n//# sourceMappingURL=index.js.map","export * from './calibration';\r\nexport * from './AccelerationProcessingNode';\r\nexport * from './RelativeOrientationProcessingNode';\r\nexport * from './GravityProcessingNode';\r\nexport * from './AbsoluteOrientationProcessingNode';\r\nexport * from './PedometerProcessingNode';\r\nexport * from './VelocityCalculationNode';\r\nexport * from './VelocityProcessingNode';\r\n//# sourceMappingURL=index.js.map","import { Acceleration, AngularVelocity, Orientation, SourceNode } from '@openhps/core';\r\nimport { IMUDataFrame } from '../../data';\r\nexport class IMUBrowserSource extends SourceNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.once('build', this._onReady.bind(this));\r\n    }\r\n    _onReady() {\r\n        window.addEventListener('devicemotion', (event) => {\r\n            const dataFrame = new IMUDataFrame();\r\n            dataFrame.acceleration = new Acceleration(event.accelerationIncludingGravity.x, event.accelerationIncludingGravity.y, event.accelerationIncludingGravity.z);\r\n            dataFrame.angularVelocity = new AngularVelocity(event.rotationRate.beta, event.rotationRate.gamma, event.rotationRate.alpha);\r\n            dataFrame.linearAcceleration = new Acceleration(event.acceleration.x, event.acceleration.y, event.acceleration.z);\r\n            const source = this.source;\r\n            source.frequency = 1000 / event.interval;\r\n            source.getPosition().angularVelocity = dataFrame.angularVelocity;\r\n            dataFrame.absoluteOrientation = source.getPosition().orientation;\r\n            dataFrame.source = source;\r\n            dataFrame.frequency = source.frequency;\r\n            this.push(dataFrame);\r\n        }, true);\r\n        window.addEventListener('deviceorientation', (event) => {\r\n            const source = this.source;\r\n            source.getPosition().orientation = Orientation.fromEuler([event.beta, event.gamma, event.alpha]);\r\n        });\r\n        this.logger('debug', {\r\n            message: 'Browser orientation and motion events registered!',\r\n        });\r\n    }\r\n    onPull() {\r\n        return new Promise((resolve) => {\r\n            resolve(undefined);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=IMUBrowserSource.js.map","export * from './IMUBrowserSource';\r\n//# sourceMappingURL=index.js.map","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nmodule.exports = x({ [\"Acceleration\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.Acceleration, [\"AccelerationUnit\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.AccelerationUnit, [\"AngularVelocity\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.AngularVelocity, [\"AxisAngle\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.AxisAngle, [\"DataFrame\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.DataFrame, [\"DataObject\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.DataObject, [\"FilterProcessingNode\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.FilterProcessingNode, [\"LengthUnit\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.LengthUnit, [\"LinearVelocity\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.LinearVelocity, [\"LinearVelocityUnit\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.LinearVelocityUnit, [\"Magnetism\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.Magnetism, [\"Matrix4\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.Matrix4, [\"ObjectProcessingNode\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.ObjectProcessingNode, [\"Orientation\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.Orientation, [\"ProcessingNode\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.ProcessingNode, [\"SerializableArrayMember\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.SerializableArrayMember, [\"SerializableMember\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.SerializableMember, [\"SerializableObject\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.SerializableObject, [\"SourceNode\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.SourceNode, [\"TimeService\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.TimeService, [\"TimeUnit\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.TimeUnit, [\"Vector3\"]: () => __WEBPACK_EXTERNAL_MODULE__openhps_core_es_js_870a26f4__.Vector3 });","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export * from './nodes';\r\nexport * from './data';\r\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}