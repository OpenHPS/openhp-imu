import*as e from"./openhps-core.es.min.js";var t={d:(e,i)=>{for(var o in i)t.o(i,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:i[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},i={};t.d(i,{cL:()=>AbsoluteOrientationProcessingNode,Rr:()=>AccelerationProcessingNode,jz:()=>n,Q2:()=>GravityProcessingNode,zD:()=>IMUBrowserSource,iD:()=>p,oS:()=>u,q_:()=>MagnetometerCalibrationNode,kp:()=>c,so:()=>PedometerProcessingNode,ZS:()=>RelativeOrientationProcessingNode,Hq:()=>VelocityCalculationNode,MB:()=>VelocityProcessingNode});const o=(e=>{var i={};return t.d(i,e),i})({Acceleration:()=>e.Acceleration,AccelerationUnit:()=>e.AccelerationUnit,AngularVelocity:()=>e.AngularVelocity,AxisAngle:()=>e.AxisAngle,DataFrame:()=>e.DataFrame,DataObject:()=>e.DataObject,FilterProcessingNode:()=>e.FilterProcessingNode,LengthUnit:()=>e.LengthUnit,LinearVelocity:()=>e.LinearVelocity,LinearVelocityUnit:()=>e.LinearVelocityUnit,Magnetism:()=>e.Magnetism,Matrix4:()=>e.Matrix4,ObjectProcessingNode:()=>e.ObjectProcessingNode,Orientation:()=>e.Orientation,ProcessingNode:()=>e.ProcessingNode,SerializableArrayMember:()=>e.SerializableArrayMember,SerializableMember:()=>e.SerializableMember,SerializableObject:()=>e.SerializableObject,SourceNode:()=>e.SourceNode,TimeService:()=>e.TimeService,TimeUnit:()=>e.TimeUnit,Vector3:()=>e.Vector3});var n,a=function(e,t,i,o){return new(i||(i=Promise))((function(n,a){function r(e){try{c(o.next(e))}catch(e){a(e)}}function s(e){try{c(o.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(r,s)}c((o=o.apply(e,t||[])).next())}))};class MagnetometerCalibrationNode extends o.ObjectProcessingNode{constructor(e){super(e)}processObject(e,t){return new Promise(((i,o)=>{this.getNodeData(e).then((o=>a(this,void 0,void 0,(function*(){if(void 0===o&&(o={xMax:0,xMin:0,yMax:0,yMin:0,zMax:0,zMin:0,count:0,scaleX:NaN,scaleY:NaN,scaleZ:NaN}),isNaN(o.scaleX)&&o.count<this.options.count&&-1!==this.options.count)o.xMax=Math.max(t.magnetism.x,o.xMax),o.xMin=Math.min(t.magnetism.x,o.xMin),o.yMax=Math.max(t.magnetism.y,o.yMax),o.yMin=Math.min(t.magnetism.y,o.yMin),o.zMax=Math.max(t.magnetism.z,o.zMax),o.zMin=Math.min(t.magnetism.z,o.zMin),o.count+=1,yield this.setNodeData(e,o);else if(isNaN(o.scaleX)&&o.count>=this.options.count){const t=(o.xMax+o.xMin)/2,i=(o.yMax+o.yMin)/2,n=(o.zMax+o.zMin)/2,a=(t+i+n)/3;o.scaleX=a/t,o.scaleY=a/i,o.scaleZ=a/n,yield this.setNodeData(e,o)}else t.magnetism.x=t.magnetism.x*o.scaleX,t.magnetism.y=t.magnetism.y*o.scaleY,t.magnetism.z=t.magnetism.z*o.scaleZ;i(e)})))).catch(o)}))}}class AccelerationProcessingNode extends o.FilterProcessingNode{initFilter(e,t){return new Promise(((e,i)=>{if(!t.acceleration&&!t.linearAcceleration)return i(new Error("Acceleration processing requires accelerometer readings!"));e({alpha:0,beta:0,gamma:0})}))}filter(e,t){return new Promise((i=>{const n=t.linearAcceleration||t.acceleration,a=1e3/t.frequency;t.linearVelocity=o.LinearVelocity.fromArray(n.clone().multiplyScalar(a).toArray());const r=e.getPosition();if(!r)return i(e);r.linearVelocity?r.linearVelocity.add(t.linearVelocity):r.linearVelocity=t.linearVelocity.clone(),i(e)}))}}class RelativeOrientationProcessingNode extends o.FilterProcessingNode{initFilter(e,t){return new Promise(((e,i)=>{if(!t.angularVelocity||!t.acceleration)return i(new Error("Relative rotation processing requires accelerometer and gyroscope readings!"));e({alpha:0,beta:0,gamma:0})}))}filter(e,t,i){return new Promise((n=>{const a=t.acceleration,r=e.getPosition().angularVelocity||t.angularVelocity,s=.98,c=1e3/t.frequency,l=Math.sqrt(Math.pow(a.x,2)+Math.pow(a.y,2)+Math.pow(a.z,2)),m=Math.PI/2,p=i.alpha+r.z*c,d=s*(i.beta+r.x*c)+(1-s)*(a.x*m/l),y=s*(i.gamma+r.y*c)+(1-s)*(a.y*-m/l);t.relativeOrientation=o.Orientation.fromEuler([d,y,p]),n(e)}))}}class GravityProcessingNode extends o.FilterProcessingNode{constructor(e){super(e),this.options.method=this.options.method||n.LOW_PASS}initFilter(e,t,i){return new Promise(((e,o)=>{if(!t.acceleration)return o(new Error("Gravity processing requires accelerometer readings!"));e(i)}))}filter(e,t){return new Promise((i=>{let o;switch(t.linearAcceleration?o=n.LINEAR_ACCELERATION:t.relativeOrientation?o=n.RELATIVE_ORIENTATION:t.absoluteOrientation&&(o=n.ABSOLUTE_ORIENTATION),o){case n.LINEAR_ACCELERATION:this._fromLinearAcceleration(t);break;case n.LOW_PASS:this._usingLPFilter(t);break;case n.ABSOLUTE_ORIENTATION:this._fromAbsoluteOrientation(t);break;default:case n.RELATIVE_ORIENTATION:this._fromRelativeOrientation(t)}i(e)}))}_fromLinearAcceleration(e){e.gravity=e.acceleration.clone().sub(e.linearAcceleration)}_usingLPFilter(e){e.gravity=new o.Acceleration,e.linearAcceleration=e.acceleration.clone().sub(e.gravity)}_fromRelativeOrientation(e){e.linearAcceleration=e.acceleration.clone().multiply(e.relativeOrientation.toEuler().toVector3()),e.gravity=e.acceleration.clone().sub(e.linearAcceleration)}_fromAbsoluteOrientation(e){e.gravity=new o.Acceleration(0,0,1,o.AccelerationUnit.GRAVITATIONAL_FORCE).applyQuaternion(e.absoluteOrientation),e.linearAcceleration=e.acceleration.clone().sub(e.gravity)}}!function(e){e[e.LOW_PASS=0]="LOW_PASS",e[e.ABSOLUTE_ORIENTATION=1]="ABSOLUTE_ORIENTATION",e[e.RELATIVE_ORIENTATION=2]="RELATIVE_ORIENTATION",e[e.LINEAR_ACCELERATION=3]="LINEAR_ACCELERATION"}(n||(n={}));class AbsoluteOrientationProcessingNode extends o.FilterProcessingNode{initFilter(e,t){return new Promise(((e,i)=>{(t.angularVelocity||void 0===t.acceleration)&&i(new Error("Relative rotation processing requires accelerometer and gyroscope readings!")),e({alpha:0,beta:0,gamma:0})}))}filter(e,t){return new Promise((i=>{const n=t.acceleration,a=t.magnetism,r=Math.atan2(-n.x,Math.sqrt(n.z*n.z+n.y*n.y)),s=Math.atan2(n.y,Math.sqrt(n.z*n.z+n.x*n.x)),c=a.x*Math.cos(r)+a.y*Math.sin(s)*Math.sin(r)+a.z*Math.cos(s)*Math.sin(r),l=a.y*Math.cos(s)-a.z*Math.sin(s);let m=Math.atan2(l,c);m<0&&(m=2*Math.PI+m),t.absoluteOrientation=o.Orientation.fromEuler([r,s,m]),i(e)}))}}var r=function(e,t,i,o){var n,a=arguments.length,r=a<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,i):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,o);else for(var s=e.length-1;s>=0;s--)(n=e[s])&&(r=(a<3?n(r):a>3?n(t,i,r):n(t,i))||r);return a>3&&r&&Object.defineProperty(t,i,r),r},s=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};class PedometerProcessingNode extends o.ProcessingNode{constructor(e){super(e),this.options.windowSize=this.options.windowSize||1,this.options.minPeak=this.options.minPeak||2,this.options.maxPeak=this.options.maxPeak||8,this.options.minStepTime=this.options.minStepTime||.3,this.options.peakThreshold=this.options.peakThreshold||.5,this.options.maxStepTime=this.options.maxStepTime||.8,this.options.meanFilterSize=this.options.meanFilterSize||1,this.options.minConsecutiveSteps=this.options.minConsecutiveSteps||3,this.options.stepSize=this.options.stepSize||.7}process(e){return new Promise(((t,i)=>{let n;this.getNodeData(e.source).then((t=>{t||(t=new c),t.add(e);const i=Math.floor(this.options.windowSize*t.frequency);return t.accelerometerData.length>4*i&&t.shift(),n=t,this.processPedometer(n)})).then((t=>{const i=t.indexOf(n.lastStepIndex);-1!==i&&(t=t.slice(i+1)),t.length>0&&(n.lastStepIndex=t[t.length-1]);const a=t.length,r=this.options.stepSize*a,s=e.source.getPosition();s.timestamp=e.createdTimestamp,s.linearVelocity=new o.LinearVelocity(r/this.options.windowSize,0,0,o.LinearVelocityUnit.METER_PER_SECOND);const c=e.absoluteOrientation||s.orientation;if(c){const e=o.Vector3.fromArray([r/this.options.windowSize,0,0]),t=c.toEuler();t.x=0,t.y=0,s.fromVector(s.toVector3(o.LengthUnit.METER).add(e.applyEuler(t)))}return this.setNodeData(e.source,n)})).then((()=>{t(e)})).catch(i)}))}processPedometer(e){return new Promise((t=>{const i=Math.floor(this.options.windowSize*e.frequency),o=this.options.minStepTime*e.frequency,n=this.options.maxStepTime*e.frequency,a=this._extractVerticalComponents(e.accelerometerData,e.attitudeData);if(a.length<i)return t([]);let r=a;this.options.meanFilterSize>1&&(r=this._meanFilter(a,this.options.meanFilterSize));const s=a.slice(0,i);let c=Math.max(this.options.minPeak,Math.min(this.options.maxPeak,Math.max(...s))),l=s.reduce(((e,t)=>e+t));const m=l/i,p=Math.ceil(i/2);let d=[],y=e.lastStepIndex;for(let e=p;e<a.length-p-1;e++){a[e]>Math.max(this.options.minPeak,this.options.peakThreshold*c+m)&&r[e]>=r[e-1]&&r[e]>r[e+1]&&y<e-o&&(a[e]<this.options.maxPeak&&d.push(e),y=e),s.push(a[e+p]);const t=s.shift();l+=a[e+p]-t,(t>=c||a[e+p]>c)&&(c=Math.max(this.options.minPeak,Math.min(this.options.maxPeak,Math.max(...s))))}if(this.options.minConsecutiveSteps>1){let e=1,t=d.length;for(;t--;)0===t||d[t]-d[t-1]<n?e++:(e<this.options.minConsecutiveSteps&&d.splice(t,e),e=1);d.length<this.options.minConsecutiveSteps&&(d=[])}t(d)}))}_extractVerticalComponents(e,t){return e.map(((e,i)=>{const o=t[i].clone();return o.z=0,e.clone().applyEuler(o).getComponent(2)}))}_meanFilter(e,t){const i=[];return e.map((o=>(i.length>=t&&i.shift(),i.push(o),i.reduce(((e,t)=>e+t))/e.length)))}}let c=class PedometerData{constructor(){this.accelerometerData=[],this.attitudeData=[],this.lastStepIndex=-1/0}add(e){return this.accelerometerData.push(e.linearAcceleration),this.attitudeData.push(e.absoluteOrientation.toEuler("ZYX")),this.frequency=e.frequency,this}shift(){return this.lastStepIndex--,this.accelerometerData.shift(),this.attitudeData.shift(),this}};r([(0,o.SerializableArrayMember)(o.Acceleration),s("design:type",Array)],c.prototype,"accelerometerData",void 0),r([(0,o.SerializableArrayMember)(o.Acceleration),s("design:type",Array)],c.prototype,"attitudeData",void 0),r([(0,o.SerializableMember)(),s("design:type",Number)],c.prototype,"frequency",void 0),r([(0,o.SerializableMember)(),s("design:type",Object)],c.prototype,"lastStepIndex",void 0),c=r([(0,o.SerializableObject)()],c);class VelocityCalculationNode extends o.ObjectProcessingNode{processObject(e){return new Promise(((t,i)=>{e.getPosition()?this.predictVelocity(e).then(t).catch(i):t(e)}))}predictVelocity(e){return new Promise((t=>{const i=this.model.findDataService(e),n=e.getPosition();i.findByUID(e.uid).then((i=>{const a=i.getPosition(),r=n.toVector3(o.LengthUnit.METER).sub(a.toVector3(o.LengthUnit.METER)),s=o.TimeService.getUnit().convert(n.timestamp-a.timestamp,o.TimeUnit.SECOND);r.divideScalar(s),n.linearVelocity=new o.LinearVelocity(r.x,r.y,r.z,o.LinearVelocityUnit.METER_PER_SECOND),t(e)})).catch((()=>{t(e)}))}))}}class VelocityProcessingNode extends o.ObjectProcessingNode{processObject(e,t){return new Promise(((i,o)=>{if(e.getPosition()){const n=e.getPosition();n.linearVelocity||n.angularVelocity?this.applyVelocity(e,t).then(i).catch(o):i(e)}else i(e)}))}applyVelocity(e,t){return new Promise((i=>{const n=e.getPosition(),a=o.TimeService.getUnit().convert(t.createdTimestamp-n.timestamp,o.TimeUnit.SECOND);if(a<0)return i(e);const r=n.linearVelocity||new o.LinearVelocity,s=n.angularVelocity||new o.AngularVelocity,c=r.clone().multiplyScalar(a),l=s.clone().multiplyScalar(a),m=o.Vector3.fromArray([0,0,0]);if(s.equals(o.Vector3.fromArray([0,0,0])))m.applyMatrix4((new o.Matrix4).makeTranslation(c.x,c.y,c.z));else if(!r.equals(o.Vector3.fromArray([0,0,0]))){const e=r.clone().divideScalar(0===s.x?1:s.x),t=r.clone().divideScalar(0===s.y?1:s.y),i=r.clone().divideScalar(0===s.z?1:s.z),n=e.min(t).min(i);m.applyMatrix4((new o.Matrix4).makeTranslation(-n.x,-n.y,-n.z)),m.applyMatrix4(new o.AxisAngle(l.x,l.y,l.z).toRotationMatrix()),m.applyMatrix4((new o.Matrix4).makeTranslation(n.x,n.y,n.z)),m.applyMatrix4(o.Matrix4.rotationFromAxisAngle(new o.Vector3(0!==s.x?1:0,0!==s.y?1:0,0!==s.z?1:0),Math.PI/2))}const p=n.clone();p.orientation||(p.orientation=new o.Orientation),p.timestamp=t.createdTimestamp,p.fromVector(p.toVector3(o.LengthUnit.METER).add(m.applyQuaternion(p.orientation)),o.LengthUnit.METER);const d=p.orientation.toEuler().toVector3().add(s.multiplyScalar(a));p.orientation=o.Orientation.fromEuler(d),e.setPosition(p),i(e)}))}}var l=function(e,t,i,o){var n,a=arguments.length,r=a<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,i):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,o);else for(var s=e.length-1;s>=0;s--)(n=e[s])&&(r=(a<3?n(r):a>3?n(t,i,r):n(t,i))||r);return a>3&&r&&Object.defineProperty(t,i,r),r},m=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};let p=class IMUDataFrame extends o.DataFrame{};l([(0,o.SerializableMember)(),m("design:type",Number)],p.prototype,"frequency",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Magnetism)],p.prototype,"magnetism",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Acceleration)],p.prototype,"acceleration",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Acceleration)],p.prototype,"linearAcceleration",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Acceleration)],p.prototype,"gravity",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Orientation)],p.prototype,"relativeOrientation",void 0),l([(0,o.SerializableMember)(),m("design:type",o.Orientation)],p.prototype,"absoluteOrientation",void 0),l([(0,o.SerializableMember)(),m("design:type",o.LinearVelocity)],p.prototype,"linearVelocity",void 0),l([(0,o.SerializableMember)(),m("design:type",o.AngularVelocity)],p.prototype,"angularVelocity",void 0),p=l([(0,o.SerializableObject)()],p);var d=function(e,t,i,o){var n,a=arguments.length,r=a<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,i):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,o);else for(var s=e.length-1;s>=0;s--)(n=e[s])&&(r=(a<3?n(r):a>3?n(t,i,r):n(t,i))||r);return a>3&&r&&Object.defineProperty(t,i,r),r},y=function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)};let u=class IMUSensorObject extends o.DataObject{};d([(0,o.SerializableMember)(),y("design:type",Number)],u.prototype,"frequency",void 0),d([(0,o.SerializableMember)(),y("design:type",o.Magnetism)],u.prototype,"magnetism",void 0),d([(0,o.SerializableMember)(),y("design:type",o.Acceleration)],u.prototype,"acceleration",void 0),d([(0,o.SerializableMember)(),y("design:type",o.Acceleration)],u.prototype,"linearAcceleration",void 0),d([(0,o.SerializableMember)(),y("design:type",o.Acceleration)],u.prototype,"gravity",void 0),u=d([(0,o.SerializableObject)()],u);class IMUBrowserSource extends o.SourceNode{constructor(e){super(e),this.once("build",this._onReady.bind(this))}_onReady(){window.addEventListener("devicemotion",(e=>{const t=new p;t.acceleration=new o.Acceleration(e.accelerationIncludingGravity.x,e.accelerationIncludingGravity.y,e.accelerationIncludingGravity.z),t.angularVelocity=new o.AngularVelocity(e.rotationRate.beta,e.rotationRate.gamma,e.rotationRate.alpha),t.linearAcceleration=new o.Acceleration(e.acceleration.x,e.acceleration.y,e.acceleration.z);const i=this.source;i.frequency=1e3/e.interval,i.getPosition().angularVelocity=t.angularVelocity,t.absoluteOrientation=i.getPosition().orientation,t.source=i,t.frequency=i.frequency,this.push(t)}),!0),window.addEventListener("deviceorientation",(e=>{this.source.getPosition().orientation=o.Orientation.fromEuler([e.beta,e.gamma,e.alpha])})),this.logger("debug",{message:"Browser orientation and motion events registered!"})}onPull(){return new Promise((e=>{e(void 0)}))}}var h=i.cL,g=i.Rr,f=i.jz,b=i.Q2,M=i.zD,A=i.iD,P=i.oS,S=i.q_,x=i.kp,O=i.so,v=i.ZS,N=i.Hq,z=i.MB;export{h as AbsoluteOrientationProcessingNode,g as AccelerationProcessingNode,f as GravityProcessingMethod,b as GravityProcessingNode,M as IMUBrowserSource,A as IMUDataFrame,P as IMUSensorObject,S as MagnetometerCalibrationNode,x as PedometerData,O as PedometerProcessingNode,v as RelativeOrientationProcessingNode,N as VelocityCalculationNode,z as VelocityProcessingNode};
//# sourceMappingURL=openhps-imu.es.min.js.map