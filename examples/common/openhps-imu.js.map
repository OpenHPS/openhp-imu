{"version":3,"file":"web/openhps-imu.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,CAAC;AACD,O;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;ACvCa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,uDAAgB;AACrC,aAAa,mBAAO,CAAC,6DAAmB;AACxC;;;;;;;;;;ACda;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,0CAAS;AAC9B,aAAa,mBAAO,CAAC,wCAAQ;AAC7B;;;;;;;;;;ACda;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,0DAAc;AACnC,aAAa,mBAAO,CAAC,kDAAU;AAC/B;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yCAAyC;AACzC,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC;AACzC;;;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC;AAClC;;;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,6BAA6B;AAC/D,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE,+BAA+B,KAAK;AACrG;;;;;;;;;;ACvEa;AACb;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,+BAA+B;AACvD,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAA2C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;AC1La;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yCAAyC;AACzC,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC;AACzC;;;;;;;;;;AClCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;;;;;;;;;;ACtCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B;AAC9B;;;;;;;;;;AC5Da;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC;AACnC,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;;;;;;;;;;ACrEa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,6GAA+B;AACpD;;;;;;;;;;ACba;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,uEAAe;AACpC,aAAa,mBAAO,CAAC,+FAA8B;AACnD,aAAa,mBAAO,CAAC,6GAAqC;AAC1D,aAAa,mBAAO,CAAC,qFAAyB;AAC9C,aAAa,mBAAO,CAAC,6GAAqC;AAC1D,aAAa,mBAAO,CAAC,yFAA2B;AAChD,aAAa,mBAAO,CAAC,yFAA2B;AAChD,aAAa,mBAAO,CAAC,uFAA0B;AAC/C;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,oCAAe;AACtC,eAAe,mBAAO,CAAC,4CAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACvCa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,uEAAoB;AACzC;;;;;;;;;;ACbA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://OpenHPS.imu/webpack/universalModuleDefinition","webpack://OpenHPS.imu/./dist/cjs/data/IMUDataFrame.js","webpack://OpenHPS.imu/./dist/cjs/data/IMUSensorObject.js","webpack://OpenHPS.imu/./dist/cjs/data/index.js","webpack://OpenHPS.imu/./dist/cjs/index.js","webpack://OpenHPS.imu/./dist/cjs/nodes/index.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/AbsoluteOrientationProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/AccelerationProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/GravityProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/PedometerProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/RelativeOrientationProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/VelocityCalculationNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/VelocityProcessingNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/calibration/MagnetometerCalibrationNode.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/calibration/index.js","webpack://OpenHPS.imu/./dist/cjs/nodes/processing/index.js","webpack://OpenHPS.imu/./dist/cjs/nodes/source/IMUBrowserSource.js","webpack://OpenHPS.imu/./dist/cjs/nodes/source/index.js","webpack://OpenHPS.imu/external umd {\"commonjs\":\"@openhps/core\",\"commonjs2\":\"@openhps/core\",\"amd\":\"core\",\"root\":[\"OpenHPS\",\"core\"]}","webpack://OpenHPS.imu/webpack/bootstrap","webpack://OpenHPS.imu/webpack/before-startup","webpack://OpenHPS.imu/webpack/startup","webpack://OpenHPS.imu/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@openhps/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"OpenHPS\", [\"core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OpenHPS\"] = factory(require(\"@openhps/core\"));\n\telse\n\t\troot[\"OpenHPS\"] = root[\"OpenHPS\"] || {}, root[\"OpenHPS\"][\"imu\"] = factory(root[\"OpenHPS\"][\"core\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__openhps_core__) {\nreturn ","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IMUDataFrame = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nlet IMUDataFrame = class IMUDataFrame extends core_1.DataFrame {\r\n};\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", Number)\r\n], IMUDataFrame.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Magnetism)\r\n], IMUDataFrame.prototype, \"magnetism\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUDataFrame.prototype, \"acceleration\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUDataFrame.prototype, \"linearAcceleration\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUDataFrame.prototype, \"gravity\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Orientation)\r\n], IMUDataFrame.prototype, \"relativeOrientation\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Orientation)\r\n], IMUDataFrame.prototype, \"absoluteOrientation\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.LinearVelocity)\r\n], IMUDataFrame.prototype, \"linearVelocity\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.AngularVelocity)\r\n], IMUDataFrame.prototype, \"angularVelocity\", void 0);\r\nIMUDataFrame = __decorate([\r\n    (0, core_1.SerializableObject)()\r\n], IMUDataFrame);\r\nexports.IMUDataFrame = IMUDataFrame;\r\n//# sourceMappingURL=IMUDataFrame.js.map","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IMUSensorObject = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nlet IMUSensorObject = class IMUSensorObject extends core_1.DataObject {\r\n};\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", Number)\r\n], IMUSensorObject.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Magnetism)\r\n], IMUSensorObject.prototype, \"magnetism\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUSensorObject.prototype, \"acceleration\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUSensorObject.prototype, \"linearAcceleration\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", core_1.Acceleration)\r\n], IMUSensorObject.prototype, \"gravity\", void 0);\r\nIMUSensorObject = __decorate([\r\n    (0, core_1.SerializableObject)()\r\n], IMUSensorObject);\r\nexports.IMUSensorObject = IMUSensorObject;\r\n//# sourceMappingURL=IMUSensorObject.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./IMUDataFrame\"), exports);\r\n__exportStar(require(\"./IMUSensorObject\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./nodes\"), exports);\r\n__exportStar(require(\"./data\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./processing\"), exports);\r\n__exportStar(require(\"./source\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AbsoluteOrientationProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass AbsoluteOrientationProcessingNode extends core_1.FilterProcessingNode {\r\n    initFilter(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (frame.angularVelocity || frame.acceleration === undefined) {\r\n                reject(new Error(`Relative rotation processing requires accelerometer and gyroscope readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.acceleration;\r\n            const mag = frame.magnetism;\r\n            const pitch = Math.atan2(-accl.x, Math.sqrt(accl.z * accl.z + accl.y * accl.y));\r\n            const roll = Math.atan2(accl.y, Math.sqrt(accl.z * accl.z + accl.x * accl.x));\r\n            const Xh = mag.x * Math.cos(pitch) +\r\n                mag.y * Math.sin(roll) * Math.sin(pitch) +\r\n                mag.z * Math.cos(roll) * Math.sin(pitch);\r\n            const Yh = mag.y * Math.cos(roll) - mag.z * Math.sin(roll);\r\n            let azimuth = Math.atan2(Yh, Xh);\r\n            if (azimuth < 0) {\r\n                azimuth = 2 * Math.PI + azimuth;\r\n            }\r\n            frame.absoluteOrientation = core_1.Orientation.fromEuler([pitch, roll, azimuth]);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\nexports.AbsoluteOrientationProcessingNode = AbsoluteOrientationProcessingNode;\r\n//# sourceMappingURL=AbsoluteOrientationProcessingNode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AccelerationProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass AccelerationProcessingNode extends core_1.FilterProcessingNode {\r\n    initFilter(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.acceleration && !frame.linearAcceleration) {\r\n                return reject(new Error(`Acceleration processing requires accelerometer readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.linearAcceleration || frame.acceleration;\r\n            const dt = 1000 / frame.frequency;\r\n            frame.linearVelocity = core_1.LinearVelocity.fromArray(accl.clone().multiplyScalar(dt).toArray());\r\n            const position = object.getPosition();\r\n            if (!position) {\r\n                return resolve(object);\r\n            }\r\n            if (!position.linearVelocity) {\r\n                position.linearVelocity = frame.linearVelocity.clone();\r\n            }\r\n            else {\r\n                position.linearVelocity.add(frame.linearVelocity);\r\n            }\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\nexports.AccelerationProcessingNode = AccelerationProcessingNode;\r\n//# sourceMappingURL=AccelerationProcessingNode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GravityProcessingMethod = exports.GravityProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass GravityProcessingNode extends core_1.FilterProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.options.method = this.options.method || GravityProcessingMethod.LOW_PASS;\r\n    }\r\n    initFilter(object, frame, options) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.acceleration) {\r\n                return reject(new Error(`Gravity processing requires accelerometer readings!`));\r\n            }\r\n            resolve(options);\r\n        });\r\n    }\r\n    filter(object, frame) {\r\n        return new Promise((resolve) => {\r\n            let method;\r\n            if (frame.linearAcceleration) {\r\n                method = GravityProcessingMethod.LINEAR_ACCELERATION;\r\n            }\r\n            else if (frame.relativeOrientation) {\r\n                method = GravityProcessingMethod.RELATIVE_ORIENTATION;\r\n            }\r\n            else if (frame.absoluteOrientation) {\r\n                method = GravityProcessingMethod.ABSOLUTE_ORIENTATION;\r\n            }\r\n            switch (method) {\r\n                case GravityProcessingMethod.LINEAR_ACCELERATION:\r\n                    this._fromLinearAcceleration(frame);\r\n                    break;\r\n                case GravityProcessingMethod.LOW_PASS:\r\n                    this._usingLPFilter(frame);\r\n                    break;\r\n                case GravityProcessingMethod.ABSOLUTE_ORIENTATION:\r\n                    this._fromAbsoluteOrientation(frame);\r\n                    break;\r\n                default:\r\n                case GravityProcessingMethod.RELATIVE_ORIENTATION:\r\n                    this._fromRelativeOrientation(frame);\r\n                    break;\r\n            }\r\n            resolve(object);\r\n        });\r\n    }\r\n    _fromLinearAcceleration(frame) {\r\n        frame.gravity = frame.acceleration.clone().sub(frame.linearAcceleration);\r\n    }\r\n    _usingLPFilter(frame) {\r\n        frame.gravity = new core_1.Acceleration();\r\n        frame.linearAcceleration = frame.acceleration.clone().sub(frame.gravity);\r\n    }\r\n    _fromRelativeOrientation(frame) {\r\n        frame.linearAcceleration = frame.acceleration.clone().multiply(frame.relativeOrientation.toEuler().toVector3());\r\n        frame.gravity = frame.acceleration.clone().sub(frame.linearAcceleration);\r\n    }\r\n    _fromAbsoluteOrientation(frame) {\r\n        frame.gravity = new core_1.Acceleration(0, 0, 1, core_1.AccelerationUnit.GRAVITATIONAL_FORCE).applyQuaternion(frame.absoluteOrientation);\r\n        frame.linearAcceleration = frame.acceleration.clone().sub(frame.gravity);\r\n    }\r\n}\r\nexports.GravityProcessingNode = GravityProcessingNode;\r\nvar GravityProcessingMethod;\r\n(function (GravityProcessingMethod) {\r\n    GravityProcessingMethod[GravityProcessingMethod[\"LOW_PASS\"] = 0] = \"LOW_PASS\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"ABSOLUTE_ORIENTATION\"] = 1] = \"ABSOLUTE_ORIENTATION\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"RELATIVE_ORIENTATION\"] = 2] = \"RELATIVE_ORIENTATION\";\r\n    GravityProcessingMethod[GravityProcessingMethod[\"LINEAR_ACCELERATION\"] = 3] = \"LINEAR_ACCELERATION\";\r\n})(GravityProcessingMethod = exports.GravityProcessingMethod || (exports.GravityProcessingMethod = {}));\r\n//# sourceMappingURL=GravityProcessingNode.js.map","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PedometerData = exports.PedometerProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass PedometerProcessingNode extends core_1.ProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.options.windowSize = this.options.windowSize || 1;\r\n        this.options.minPeak = this.options.minPeak || 2;\r\n        this.options.maxPeak = this.options.maxPeak || 8;\r\n        this.options.minStepTime = this.options.minStepTime || 0.3;\r\n        this.options.peakThreshold = this.options.peakThreshold || 0.5;\r\n        this.options.maxStepTime = this.options.maxStepTime || 0.8;\r\n        this.options.meanFilterSize = this.options.meanFilterSize || 1;\r\n        this.options.minConsecutiveSteps = this.options.minConsecutiveSteps || 3;\r\n        this.options.stepSize = this.options.stepSize || 0.7;\r\n    }\r\n    process(frame) {\r\n        return new Promise((resolve, reject) => {\r\n            let pedometerData;\r\n            this.getNodeData(frame.source)\r\n                .then((data) => {\r\n                if (!data) {\r\n                    data = new PedometerData();\r\n                }\r\n                data.add(frame);\r\n                const windowSize = Math.floor(this.options.windowSize * data.frequency);\r\n                if (data.accelerometerData.length > 4 * windowSize) {\r\n                    data.shift();\r\n                }\r\n                pedometerData = data;\r\n                return this.processPedometer(pedometerData);\r\n            })\r\n                .then((steps) => {\r\n                const previousStep = steps.indexOf(pedometerData.lastStepIndex);\r\n                if (previousStep !== -1) {\r\n                    steps = steps.slice(previousStep + 1);\r\n                }\r\n                if (steps.length > 0) {\r\n                    pedometerData.lastStepIndex = steps[steps.length - 1];\r\n                }\r\n                const stepCount = steps.length;\r\n                const distance = this.options.stepSize * stepCount;\r\n                const position = frame.source.getPosition();\r\n                position.timestamp = frame.createdTimestamp;\r\n                position.linearVelocity = new core_1.LinearVelocity(distance / this.options.windowSize, 0, 0, core_1.LinearVelocityUnit.METER_PER_SECOND);\r\n                const orientation = frame.absoluteOrientation || position.orientation;\r\n                if (orientation) {\r\n                    const relativePosition = core_1.Vector3.fromArray([distance / this.options.windowSize, 0, 0]);\r\n                    const eulerOrientation = orientation.toEuler();\r\n                    eulerOrientation.x = 0;\r\n                    eulerOrientation.y = 0;\r\n                    position.fromVector(position.toVector3(core_1.LengthUnit.METER).add(relativePosition.applyEuler(eulerOrientation)));\r\n                }\r\n                return this.setNodeData(frame.source, pedometerData);\r\n            })\r\n                .then(() => {\r\n                resolve(frame);\r\n            })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    processPedometer(data) {\r\n        return new Promise((resolve) => {\r\n            const windowSize = Math.floor(this.options.windowSize * data.frequency);\r\n            const taoMin = this.options.minStepTime * data.frequency;\r\n            const taoMax = this.options.maxStepTime * data.frequency;\r\n            const verticalComponent = this._extractVerticalComponents(data.accelerometerData, data.attitudeData);\r\n            if (verticalComponent.length < windowSize) {\r\n                return resolve([]);\r\n            }\r\n            let smoothedVerticalComponent = verticalComponent;\r\n            if (this.options.meanFilterSize > 1) {\r\n                smoothedVerticalComponent = this._meanFilter(verticalComponent, this.options.meanFilterSize);\r\n            }\r\n            const window = verticalComponent.slice(0, windowSize);\r\n            let windowMax = Math.max(this.options.minPeak, Math.min(this.options.maxPeak, Math.max(...window)));\r\n            let windowSum = window.reduce((a, b) => a + b);\r\n            const windowAvg = windowSum / windowSize;\r\n            const offset = Math.ceil(windowSize / 2);\r\n            let steps = [];\r\n            let lastPeak = data.lastStepIndex;\r\n            for (let i = offset; i < verticalComponent.length - offset - 1; i++) {\r\n                if (verticalComponent[i] >\r\n                    Math.max(this.options.minPeak, this.options.peakThreshold * windowMax + windowAvg) &&\r\n                    smoothedVerticalComponent[i] >= smoothedVerticalComponent[i - 1] &&\r\n                    smoothedVerticalComponent[i] > smoothedVerticalComponent[i + 1] &&\r\n                    lastPeak < i - taoMin) {\r\n                    if (verticalComponent[i] < this.options.maxPeak)\r\n                        steps.push(i);\r\n                    lastPeak = i;\r\n                }\r\n                window.push(verticalComponent[i + offset]);\r\n                const removed = window.shift();\r\n                windowSum += verticalComponent[i + offset] - removed;\r\n                if (removed >= windowMax || verticalComponent[i + offset] > windowMax) {\r\n                    windowMax = Math.max(this.options.minPeak, Math.min(this.options.maxPeak, Math.max(...window)));\r\n                }\r\n            }\r\n            if (this.options.minConsecutiveSteps > 1) {\r\n                let consecutivePeaks = 1;\r\n                let i = steps.length;\r\n                while (i--) {\r\n                    if (i === 0 || steps[i] - steps[i - 1] < taoMax) {\r\n                        consecutivePeaks++;\r\n                    }\r\n                    else {\r\n                        if (consecutivePeaks < this.options.minConsecutiveSteps) {\r\n                            steps.splice(i, consecutivePeaks);\r\n                        }\r\n                        consecutivePeaks = 1;\r\n                    }\r\n                }\r\n                if (steps.length < this.options.minConsecutiveSteps) {\r\n                    steps = [];\r\n                }\r\n            }\r\n            resolve(steps);\r\n        });\r\n    }\r\n    _extractVerticalComponents(accelerometerData, attitudeData) {\r\n        return accelerometerData.map((acceleration, i) => {\r\n            const attitude = attitudeData[i].clone();\r\n            attitude.z = 0;\r\n            return acceleration.clone().applyEuler(attitude).getComponent(2);\r\n        });\r\n    }\r\n    _meanFilter(arr, size) {\r\n        const window = [];\r\n        return arr.map((val) => {\r\n            if (window.length >= size)\r\n                window.shift();\r\n            window.push(val);\r\n            return window.reduce((a, b) => a + b) / arr.length;\r\n        });\r\n    }\r\n}\r\nexports.PedometerProcessingNode = PedometerProcessingNode;\r\nlet PedometerData = class PedometerData {\r\n    constructor() {\r\n        this.accelerometerData = [];\r\n        this.attitudeData = [];\r\n        this.lastStepIndex = -Infinity;\r\n    }\r\n    add(frame) {\r\n        this.accelerometerData.push(frame.linearAcceleration);\r\n        this.attitudeData.push(frame.absoluteOrientation.toEuler('ZYX'));\r\n        this.frequency = frame.frequency;\r\n        return this;\r\n    }\r\n    shift() {\r\n        this.lastStepIndex--;\r\n        this.accelerometerData.shift();\r\n        this.attitudeData.shift();\r\n        return this;\r\n    }\r\n};\r\n__decorate([\r\n    (0, core_1.SerializableArrayMember)(core_1.Acceleration),\r\n    __metadata(\"design:type\", Array)\r\n], PedometerData.prototype, \"accelerometerData\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableArrayMember)(core_1.Acceleration),\r\n    __metadata(\"design:type\", Array)\r\n], PedometerData.prototype, \"attitudeData\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", Number)\r\n], PedometerData.prototype, \"frequency\", void 0);\r\n__decorate([\r\n    (0, core_1.SerializableMember)(),\r\n    __metadata(\"design:type\", Object)\r\n], PedometerData.prototype, \"lastStepIndex\", void 0);\r\nPedometerData = __decorate([\r\n    (0, core_1.SerializableObject)()\r\n], PedometerData);\r\nexports.PedometerData = PedometerData;\r\n//# sourceMappingURL=PedometerProcessingNode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RelativeOrientationProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass RelativeOrientationProcessingNode extends core_1.FilterProcessingNode {\r\n    initFilter(_, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!frame.angularVelocity || !frame.acceleration) {\r\n                return reject(new Error(`Relative rotation processing requires accelerometer and gyroscope readings!`));\r\n            }\r\n            resolve({\r\n                alpha: 0,\r\n                beta: 0,\r\n                gamma: 0,\r\n            });\r\n        });\r\n    }\r\n    filter(object, frame, filter) {\r\n        return new Promise((resolve) => {\r\n            const accl = frame.acceleration;\r\n            const gyro = object.getPosition().angularVelocity || frame.angularVelocity;\r\n            const bias = 0.98;\r\n            const dt = 1000 / frame.frequency;\r\n            const norm = Math.sqrt(Math.pow(accl.x, 2) + Math.pow(accl.y, 2) + Math.pow(accl.z, 2));\r\n            const scale = Math.PI / 2;\r\n            const alpha = filter.alpha + gyro.z * dt;\r\n            const beta = bias * (filter.beta + gyro.x * dt) + (1.0 - bias) * ((accl.x * scale) / norm);\r\n            const gamma = bias * (filter.gamma + gyro.y * dt) + (1.0 - bias) * ((accl.y * -scale) / norm);\r\n            frame.relativeOrientation = core_1.Orientation.fromEuler([beta, gamma, alpha]);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\nexports.RelativeOrientationProcessingNode = RelativeOrientationProcessingNode;\r\n//# sourceMappingURL=RelativeOrientationProcessingNode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VelocityCalculationNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass VelocityCalculationNode extends core_1.ObjectProcessingNode {\r\n    processObject(object) {\r\n        return new Promise((resolve, reject) => {\r\n            if (object.getPosition()) {\r\n                this.predictVelocity(object).then(resolve).catch(reject);\r\n            }\r\n            else {\r\n                resolve(object);\r\n            }\r\n        });\r\n    }\r\n    predictVelocity(object) {\r\n        return new Promise((resolve) => {\r\n            const service = this.model.findDataService(object);\r\n            const position = object.getPosition();\r\n            service\r\n                .findByUID(object.uid)\r\n                .then((existingObject) => {\r\n                const existingPosition = existingObject.getPosition();\r\n                const difference = position\r\n                    .toVector3(core_1.LengthUnit.METER)\r\n                    .sub(existingPosition.toVector3(core_1.LengthUnit.METER));\r\n                const timeDifference = core_1.TimeService.getUnit().convert(position.timestamp - existingPosition.timestamp, core_1.TimeUnit.SECOND);\r\n                difference.divideScalar(timeDifference);\r\n                position.linearVelocity = new core_1.LinearVelocity(difference.x, difference.y, difference.z, core_1.LinearVelocityUnit.METER_PER_SECOND);\r\n                resolve(object);\r\n            })\r\n                .catch(() => {\r\n                resolve(object);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.VelocityCalculationNode = VelocityCalculationNode;\r\n//# sourceMappingURL=VelocityCalculationNode.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VelocityProcessingNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass VelocityProcessingNode extends core_1.ObjectProcessingNode {\r\n    processObject(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            if (object.getPosition()) {\r\n                const lastPosition = object.getPosition();\r\n                if (lastPosition.linearVelocity || lastPosition.angularVelocity) {\r\n                    this.applyVelocity(object, frame).then(resolve).catch(reject);\r\n                }\r\n                else {\r\n                    resolve(object);\r\n                }\r\n            }\r\n            else {\r\n                resolve(object);\r\n            }\r\n        });\r\n    }\r\n    applyVelocity(object, frame) {\r\n        return new Promise((resolve) => {\r\n            const lastPosition = object.getPosition();\r\n            const deltaTime = core_1.TimeService.getUnit().convert(frame.createdTimestamp - lastPosition.timestamp, core_1.TimeUnit.SECOND);\r\n            if (deltaTime < 0) {\r\n                return resolve(object);\r\n            }\r\n            const linear = lastPosition.linearVelocity || new core_1.LinearVelocity();\r\n            const angular = lastPosition.angularVelocity || new core_1.AngularVelocity();\r\n            const linearMovement = linear.clone().multiplyScalar(deltaTime);\r\n            const angularMovement = angular.clone().multiplyScalar(deltaTime);\r\n            const relativePosition = core_1.Vector3.fromArray([0, 0, 0]);\r\n            if (angular.equals(core_1.Vector3.fromArray([0, 0, 0]))) {\r\n                relativePosition.applyMatrix4(new core_1.Matrix4().makeTranslation(linearMovement.x, linearMovement.y, linearMovement.z));\r\n            }\r\n            else if (!linear.equals(core_1.Vector3.fromArray([0, 0, 0]))) {\r\n                const rX = linear.clone().divideScalar(angular.x === 0 ? 1 : angular.x);\r\n                const rY = linear.clone().divideScalar(angular.y === 0 ? 1 : angular.y);\r\n                const rZ = linear.clone().divideScalar(angular.z === 0 ? 1 : angular.z);\r\n                const rMin = rX.min(rY).min(rZ);\r\n                relativePosition.applyMatrix4(new core_1.Matrix4().makeTranslation(-rMin.x, -rMin.y, -rMin.z));\r\n                relativePosition.applyMatrix4(new core_1.AxisAngle(angularMovement.x, angularMovement.y, angularMovement.z).toRotationMatrix());\r\n                relativePosition.applyMatrix4(new core_1.Matrix4().makeTranslation(rMin.x, rMin.y, rMin.z));\r\n                relativePosition.applyMatrix4(core_1.Matrix4.rotationFromAxisAngle(new core_1.Vector3(angular.x !== 0 ? 1 : 0, angular.y !== 0 ? 1 : 0, angular.z !== 0 ? 1 : 0), Math.PI / 2));\r\n            }\r\n            const newPosition = lastPosition.clone();\r\n            if (!newPosition.orientation) {\r\n                newPosition.orientation = new core_1.Orientation();\r\n            }\r\n            newPosition.timestamp = frame.createdTimestamp;\r\n            newPosition.fromVector(newPosition.toVector3(core_1.LengthUnit.METER).add(relativePosition.applyQuaternion(newPosition.orientation)), core_1.LengthUnit.METER);\r\n            const newOrientation = newPosition.orientation.toEuler().toVector3().add(angular.multiplyScalar(deltaTime));\r\n            newPosition.orientation = core_1.Orientation.fromEuler(newOrientation);\r\n            object.setPosition(newPosition);\r\n            resolve(object);\r\n        });\r\n    }\r\n}\r\nexports.VelocityProcessingNode = VelocityProcessingNode;\r\n//# sourceMappingURL=VelocityProcessingNode.js.map","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MagnetometerCalibrationNode = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nclass MagnetometerCalibrationNode extends core_1.ObjectProcessingNode {\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n    processObject(object, frame) {\r\n        return new Promise((resolve, reject) => {\r\n            this.getNodeData(object)\r\n                .then((calibrationData) => __awaiter(this, void 0, void 0, function* () {\r\n                if (calibrationData === undefined) {\r\n                    calibrationData = {\r\n                        xMax: 0,\r\n                        xMin: 0,\r\n                        yMax: 0,\r\n                        yMin: 0,\r\n                        zMax: 0,\r\n                        zMin: 0,\r\n                        count: 0,\r\n                        scaleX: NaN,\r\n                        scaleY: NaN,\r\n                        scaleZ: NaN,\r\n                    };\r\n                }\r\n                if (isNaN(calibrationData.scaleX) &&\r\n                    calibrationData.count < this.options.count &&\r\n                    this.options.count !== -1) {\r\n                    calibrationData.xMax = Math.max(frame.magnetism.x, calibrationData.xMax);\r\n                    calibrationData.xMin = Math.min(frame.magnetism.x, calibrationData.xMin);\r\n                    calibrationData.yMax = Math.max(frame.magnetism.y, calibrationData.yMax);\r\n                    calibrationData.yMin = Math.min(frame.magnetism.y, calibrationData.yMin);\r\n                    calibrationData.zMax = Math.max(frame.magnetism.z, calibrationData.zMax);\r\n                    calibrationData.zMin = Math.min(frame.magnetism.z, calibrationData.zMin);\r\n                    calibrationData.count += 1;\r\n                    yield this.setNodeData(object, calibrationData);\r\n                }\r\n                else if (isNaN(calibrationData.scaleX) && calibrationData.count >= this.options.count) {\r\n                    const avgDeltaX = (calibrationData.xMax + calibrationData.xMin) / 2;\r\n                    const avgDeltaY = (calibrationData.yMax + calibrationData.yMin) / 2;\r\n                    const avgDeltaZ = (calibrationData.zMax + calibrationData.zMin) / 2;\r\n                    const avgDelta = (avgDeltaX + avgDeltaY + avgDeltaZ) / 3;\r\n                    calibrationData.scaleX = avgDelta / avgDeltaX;\r\n                    calibrationData.scaleY = avgDelta / avgDeltaY;\r\n                    calibrationData.scaleZ = avgDelta / avgDeltaZ;\r\n                    yield this.setNodeData(object, calibrationData);\r\n                }\r\n                else {\r\n                    frame.magnetism.x = frame.magnetism.x * calibrationData.scaleX;\r\n                    frame.magnetism.y = frame.magnetism.y * calibrationData.scaleY;\r\n                    frame.magnetism.z = frame.magnetism.z * calibrationData.scaleZ;\r\n                }\r\n                resolve(object);\r\n            }))\r\n                .catch(reject);\r\n        });\r\n    }\r\n}\r\nexports.MagnetometerCalibrationNode = MagnetometerCalibrationNode;\r\n//# sourceMappingURL=MagnetometerCalibrationNode.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./MagnetometerCalibrationNode\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./calibration\"), exports);\r\n__exportStar(require(\"./AccelerationProcessingNode\"), exports);\r\n__exportStar(require(\"./RelativeOrientationProcessingNode\"), exports);\r\n__exportStar(require(\"./GravityProcessingNode\"), exports);\r\n__exportStar(require(\"./AbsoluteOrientationProcessingNode\"), exports);\r\n__exportStar(require(\"./PedometerProcessingNode\"), exports);\r\n__exportStar(require(\"./VelocityCalculationNode\"), exports);\r\n__exportStar(require(\"./VelocityProcessingNode\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IMUBrowserSource = void 0;\r\nconst core_1 = require(\"@openhps/core\");\r\nconst data_1 = require(\"../../data\");\r\nclass IMUBrowserSource extends core_1.SourceNode {\r\n    constructor(options) {\r\n        super(options);\r\n        this.once('build', this._onReady.bind(this));\r\n    }\r\n    _onReady() {\r\n        window.addEventListener('devicemotion', (event) => {\r\n            const dataFrame = new data_1.IMUDataFrame();\r\n            dataFrame.acceleration = new core_1.Acceleration(event.accelerationIncludingGravity.x, event.accelerationIncludingGravity.y, event.accelerationIncludingGravity.z);\r\n            dataFrame.angularVelocity = new core_1.AngularVelocity(event.rotationRate.beta, event.rotationRate.gamma, event.rotationRate.alpha);\r\n            dataFrame.linearAcceleration = new core_1.Acceleration(event.acceleration.x, event.acceleration.y, event.acceleration.z);\r\n            const source = this.source;\r\n            source.frequency = 1000 / event.interval;\r\n            source.getPosition().angularVelocity = dataFrame.angularVelocity;\r\n            dataFrame.absoluteOrientation = source.getPosition().orientation;\r\n            dataFrame.source = source;\r\n            dataFrame.frequency = source.frequency;\r\n            this.push(dataFrame);\r\n        }, true);\r\n        window.addEventListener('deviceorientation', (event) => {\r\n            const source = this.source;\r\n            source.getPosition().orientation = core_1.Orientation.fromEuler([event.beta, event.gamma, event.alpha]);\r\n        });\r\n        this.logger('debug', {\r\n            message: 'Browser orientation and motion events registered!',\r\n        });\r\n    }\r\n    onPull() {\r\n        return new Promise((resolve) => {\r\n            resolve(undefined);\r\n        });\r\n    }\r\n}\r\nexports.IMUBrowserSource = IMUBrowserSource;\r\n//# sourceMappingURL=IMUBrowserSource.js.map","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./IMUBrowserSource\"), exports);\r\n//# sourceMappingURL=index.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__openhps_core__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./dist/cjs/index.js\");\n",""],"names":[],"sourceRoot":""}