{"version":3,"file":"web/openhps-web-sensors.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,CAAC;AACD,O;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,2BAA2B,mBAAO,CAAC,kEAAwB;AAC3D,oDAAmD,EAAE,qCAAqC,+CAA+C,EAAC;AAC1I,2BAA2B,mBAAO,CAAC,wEAA2B;AAC9D,+CAA+C,wDAAwD,IAAI;AAC3G;;;;;;;;;;ACPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACxDa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,oCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,kBAAkB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACpKA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://OpenHPS.sensors/webpack/universalModuleDefinition","webpack://OpenHPS.sensors/./dist/cjs/index.js","webpack://OpenHPS.sensors/./dist/cjs/legacy/SensorSourceNode.js","webpack://OpenHPS.sensors/./dist/cjs/web/SensorSourceNode.js","webpack://OpenHPS.sensors/external umd {\"commonjs\":\"@openhps/core\",\"commonjs2\":\"@openhps/core\",\"amd\":\"core\",\"root\":[\"OpenHPS\",\"core\"]}","webpack://OpenHPS.sensors/webpack/bootstrap","webpack://OpenHPS.sensors/webpack/before-startup","webpack://OpenHPS.sensors/webpack/startup","webpack://OpenHPS.sensors/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@openhps/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"OpenHPS\", [\"core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OpenHPS\"] = factory(require(\"@openhps/core\"));\n\telse\n\t\troot[\"OpenHPS\"] = root[\"OpenHPS\"] || {}, root[\"OpenHPS\"][\"sensors\"] = factory(root[\"OpenHPS\"][\"core\"]);\n})((typeof self !== 'undefined' ? self : this), (__WEBPACK_EXTERNAL_MODULE__openhps_core__) => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SensorSourceNode = void 0;\nconst SensorSourceNode_1 = require(\"./web/SensorSourceNode\");\nObject.defineProperty(exports, \"SensorSourceNode\", { enumerable: true, get: function () { return SensorSourceNode_1.SensorSourceNode; } });\nconst SensorSourceNode_2 = require(\"./legacy/SensorSourceNode\");\nmodule.exports = 'Accelerometer' in window ? { SensorSourceNode: SensorSourceNode_1.SensorSourceNode } : { SensorSourceNode: SensorSourceNode_2.SensorSourceNode };\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SensorSourceNode = void 0;\nconst core_1 = require(\"@openhps/core\");\n/**\n * IMU source using the HTML5 browser API for device motion and device orientation.\n *\n * @category Source node\n */\nclass SensorSourceNode extends core_1.SourceNode {\n    constructor(options) {\n        var _a;\n        super(options);\n        this.options.source = (_a = this.options.source) !== null && _a !== void 0 ? _a : new core_1.DataObject(this.uid);\n        if (this.options.autoStart) {\n            this.once('build', this.start.bind(this));\n        }\n        this.once('destroy', this.stop.bind(this));\n    }\n    requestPermission() {\n        return Promise.resolve();\n    }\n    start() {\n        return new Promise((resolve) => {\n            const sensorUID = this.source ? this.source.uid : this.uid;\n            window.addEventListener('devicemotion', (event) => {\n                // Create a new data frame for the orientation change\n                const dataFrame = new core_1.DataFrame();\n                const frequency = 1000 / event.interval;\n                dataFrame.addSensor(new core_1.Accelerometer(sensorUID + '_accl', new core_1.Acceleration(event.accelerationIncludingGravity.x, event.accelerationIncludingGravity.y, event.accelerationIncludingGravity.z), frequency));\n                dataFrame.addSensor(new core_1.Gyroscope(sensorUID + '_gyro', new core_1.AngularVelocity(event.rotationRate.beta, event.rotationRate.gamma, event.rotationRate.alpha), frequency));\n                dataFrame.addSensor(new core_1.Accelerometer(sensorUID + '_linearaccl', new core_1.Acceleration(event.acceleration.x, event.acceleration.y, event.acceleration.z), frequency));\n                const source = this.source;\n                source.getPosition().angularVelocity = dataFrame.getSensor(core_1.Gyroscope).value;\n                dataFrame.addSensor(new core_1.AbsoluteOrientationSensor(sensorUID + '_orientation', source.getPosition().orientation));\n                dataFrame.source = source;\n                this.push(dataFrame);\n            }, true);\n            window.addEventListener('deviceorientation', (event) => {\n                const source = this.source;\n                source.getPosition().orientation = core_1.Orientation.fromEuler([event.beta, event.gamma, event.alpha]);\n            });\n            this.logger('debug', 'Browser orientation and motion events registered!');\n            resolve();\n        });\n    }\n    stop() {\n        return Promise.resolve();\n    }\n    onPull() {\n        return new Promise((resolve) => {\n            resolve(undefined);\n        });\n    }\n}\nexports.SensorSourceNode = SensorSourceNode;\n//# sourceMappingURL=SensorSourceNode.js.map","\"use strict\";\n/// <reference types=\"web\" />\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SensorSourceNode = void 0;\nconst core_1 = require(\"@openhps/core\");\n/**\n * Sensor source node using Web Sensor API.\n */\nclass SensorSourceNode extends core_1.SourceNode {\n    constructor(options) {\n        super(options);\n        this._subscriptions = new Map();\n        this._values = new Map();\n        this._lastPush = 0;\n        this._running = false;\n        this.options.interval = this.options.interval || 100;\n        if (this.options.autoStart) {\n            this.once('build', this.start.bind(this));\n        }\n        this.once('destroy', this.stop.bind(this));\n    }\n    static checkPermissions(sensors) {\n        return this.requestPermissions(sensors);\n    }\n    static requestPermissions(sensors) {\n        return new Promise((resolve, reject) => {\n            Promise.all(sensors\n                .map((sensor) => this.getPermissions(sensor).map((permission) => navigator.permissions.query({ name: permission })))\n                .reduce((a, b) => [...a, ...b]))\n                .then((results) => {\n                if (results.every((result) => result.state === 'granted')) {\n                    resolve(true);\n                }\n                else {\n                    resolve(false);\n                }\n            })\n                .catch(reject);\n        });\n    }\n    start() {\n        return new Promise((resolve) => {\n            this._running = true;\n            if (this._subscriptions.size > 0) {\n                return resolve();\n            }\n            this.options.sensors.forEach((sensor) => {\n                const SensorType = this.findSensor(sensor);\n                const sensorInstance = new SensorType({\n                    frequency: Math.round(1000 / this.options.interval),\n                });\n                sensorInstance.addEventListener('reading', (event) => {\n                    if (!this._running)\n                        return;\n                    this._values.set(sensor, event.target);\n                    if (this._isUpdated()) {\n                        this._lastPush = event.timeStamp;\n                        this.createFrame().catch((ex) => {\n                            this.logger('error', 'Unable to create sensor data frame!', ex);\n                        });\n                    }\n                });\n                sensorInstance.start();\n                this._subscriptions.set(sensor, sensorInstance);\n            });\n            resolve();\n        });\n    }\n    _isUpdated() {\n        return (Array.from(this._values.values()).filter((sensor) => sensor.timestamp > this._lastPush).length ===\n            Array.from(this._subscriptions.values()).filter((sensor) => sensor.activated).length);\n    }\n    stop() {\n        return new Promise((resolve) => {\n            if (this.options.softStop) {\n                this._running = false;\n            }\n            else {\n                this._subscriptions.forEach((value) => value.stop());\n                this._subscriptions = new Map();\n                this._values = new Map();\n            }\n            resolve();\n        });\n    }\n    createFrame() {\n        return new Promise((resolve) => {\n            const dataFrame = new core_1.DataFrame();\n            dataFrame.source = this.source;\n            const acceleration = this._values.get(core_1.Accelerometer);\n            const linearAcceleration = this._values.get(core_1.LinearAccelerationSensor);\n            const gyroscope = this._values.get(core_1.Gyroscope);\n            const orientation = this._values.get(core_1.AbsoluteOrientationSensor);\n            const relativeOrientation = this._values.get(core_1.RelativeOrientationSensor);\n            const magnetometer = this._values.get(core_1.Magnetometer);\n            const sourceUID = this.source ? this.source.uid : this.uid;\n            const frequency = 1000 / this.options.interval;\n            if (acceleration) {\n                dataFrame.addSensor(new core_1.Accelerometer(sourceUID + '_accel', new core_1.Acceleration(acceleration.x, acceleration.y, acceleration.z), frequency));\n            }\n            if (linearAcceleration) {\n                dataFrame.addSensor(new core_1.LinearAccelerationSensor(sourceUID + '_linearaccel', new core_1.Acceleration(linearAcceleration.x, linearAcceleration.y, linearAcceleration.z), frequency));\n            }\n            if (gyroscope) {\n                dataFrame.addSensor(new core_1.Gyroscope(sourceUID + '_gyro', new core_1.AngularVelocity(gyroscope.x, gyroscope.y, gyroscope.z, core_1.AngularVelocityUnit.RADIAN_PER_SECOND), frequency));\n            }\n            if (orientation) {\n                dataFrame.addSensor(new core_1.AbsoluteOrientationSensor(sourceUID + '_absoluteorientation', core_1.Orientation.fromQuaternion(new core_1.Quaternion(...orientation.quaternion)), frequency));\n            }\n            if (relativeOrientation) {\n                dataFrame.addSensor(new core_1.RelativeOrientationSensor(sourceUID + '_relativeorientation', core_1.Orientation.fromQuaternion(new core_1.Quaternion(...relativeOrientation.quaternion)), frequency));\n            }\n            if (magnetometer) {\n                dataFrame.addSensor(new core_1.Magnetometer(sourceUID + '_mag', new core_1.Magnetism(magnetometer.x, magnetometer.y, magnetometer.z), frequency));\n            }\n            this.push(dataFrame);\n            resolve();\n        });\n    }\n    onPull() {\n        return new Promise((resolve) => {\n            resolve(undefined);\n        });\n    }\n    findSensor(sensor) {\n        switch (sensor) {\n            case core_1.RelativeOrientationSensor:\n                return RelativeOrientationSensor;\n            case core_1.AbsoluteOrientationSensor:\n                return AbsoluteOrientationSensor;\n            case core_1.LinearAccelerationSensor:\n                return LinearAccelerationSensor;\n            // case SensorType.AMBIENT_LIGHT:\n            //     return AmbientLightSensor;\n            case core_1.Gyroscope:\n                return Gyroscope;\n            case core_1.Magnetometer:\n                return Magnetometer;\n            case core_1.Accelerometer:\n                return Accelerometer;\n            default:\n                return undefined;\n        }\n    }\n    static getPermissions(sensor) {\n        switch (sensor) {\n            // case SensorType.AMBIENT_LIGHT:\n            //     return [\"ambient-light-sensor\"];\n            case core_1.RelativeOrientationSensor:\n            case core_1.AbsoluteOrientationSensor:\n                return ['gyroscope', 'accelerometer', 'magnetometer'];\n            case core_1.Gyroscope:\n                return ['gyroscope'];\n            case core_1.Magnetometer:\n                return ['magnetometer'];\n            case core_1.LinearAccelerationSensor:\n            case core_1.Accelerometer:\n                return ['accelerometer'];\n            default:\n                return undefined;\n        }\n    }\n}\nexports.SensorSourceNode = SensorSourceNode;\n//# sourceMappingURL=SensorSourceNode.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__openhps_core__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./dist/cjs/index.js\");\n",""],"names":[],"sourceRoot":""}